buscar elementos desde arriba y abajo

en la función que me hace tres grupos desde uno no desordenar el poco orden de los swaps

plantearme hacer tres grupos a partir del último que queda

usar los rr rrr y ss mucho más si es posible

para no desordenar al hacer tres grupos no hacer push rotate si no rotate push



lo mejor es solo cambiar el que guarde los elementos cuando sea necesario
y mientras hago eso estaría bien hacer ss

también mirar si me vendría bien hacer rr y rrr

mirar como de complejo sería el código de las cadenas y de dividir los grupos mayores
hasta que sean muy pequeños sin dar vueltas de un lado a otro

pensar también en hacer cosas en base al tamaño de los grupos actuales



en sort_biggest hacer grupos de 3 en vez de 2



en sort_b_a guardar los elementos:
en este ejemplo sería que al buscar el 73 como el 72 está antes que lo empuje al
otro y quiero que al final quede como el primero desde abajo el 71 que quede justo
encima desde abajo, entonces cuando se encuentra primero el 72 y luego el 71
se empujan por orden

en este caso buscamos primero el 73, el 72 después y lo encontramos antes y lo
empujo y no lo roto para que lo que ponga por encima no se modifique al rotarlo
paso a buscar el 71 y lo empujo, roto estos dos y al rotarlos de nuevo estarían
ordenados del 73 al 71

entonces la lógica sería hacer push a los elementos si los encuentra en orden inverso
hasta el elemento primero que estábamos buscando se hace push a todo y luego rotate,
si se encuentran en orden creciente hasta el primer elemento hay que mandarlo
y rotarlo 

tengo que pensar las condiciones para seguir buscando números

los que vayan después de el 73 tengo que dejarlos en orden abajo del stack
para eso los recursos que tengo son primero el más pequeño de los que recoja tiene
que ser el primero en rotar osea que podría primero hacer push al 72, p al 71,
p al 70, pr al 69 y como el 68 está después del 69 al que ya he hecho pr está el 68
ya no tendría disponible la parte más interna del stack para salir el último
aunque podría esperar a hacer rotate al 69 hasta que haya entrado el 68

entonces lo que puedo hacer es rotar el elemento antes de que entre uno mayor

lo ideal es que aparezcan los números en orden para luego rotarlos


primero buscamos la posición del siguiente al 73, el 72 que está antes, y hay que
dejarlo al fondo, lo siguiente es el 71 que hay que dejarlo encima del 72,
si está antes como hay que rotarlo antes que el 72 habría que rotarlo
antes que el 72 y por hacerlo rotar primero ya no puedo meter el número siguiente
a no ser que lo encuentre antes que el siguiente que tengo que hacer push


RESUMEN: cuando encuentro el elemento pequeño si encuentro un elemento al que hacer
push hace que ya no pueda meter nada más

por ejemplo si estoy buscando el cuarto elemento para ordenar (s_b - 4) y
el quinto elemento tiene un índice mayor que (s_b - x) siendo x < 4 y el índice no
es menor que el de (s_b - 4) ya que si no podría ser el primero en rotarse y seguir
buscando

entonces lo que necesito es la posición de los elementos que vaya encontrando
y comprobar que la posición del elemento actual es menor que alguna de las anteriores
lo que significa que hay que rotar este elemento en algún momento y buscar el siguiente
que se podría añadir en caso de estar antes que otro elemento a pushear, si
este elemento está antes que el anterior hay que rotarlo antes si está después
hay que esperar a rotar los dos

lo que tengo que hacer es primero el programa que busque y se guarde los índices,
luego tener un programa que durante este proceso elija si tiene que rotarlos ahora
o más tarde

todo el rato ir buscando hasta condición de parar, la condición de parar simplificada
es encontrar un elemento que esté antes de otro elemento antes del primero y que
el siguiente elemento a buscar no esté después de este elemento anterior al primero



EJEMPLOS:

(s_a - 1) es 1, (s_a - 2) es 2 y sucesivamente

5
4
3
2
1
aquí se hace pushrotate de todo directamente super fácil

3
6
5
1
4
2


4  2
2  4
5  5
3  3
1  1
en este orden el 5 ya no podría incluirse en los elementos que dejaremos abajo
porque está después del 2 

4
5
2
3
1
en este ejemplo el 5 sí que entra porque se quedaría encima del 4 y se rotan los dos
antes de llegar al 2

En base a los ejemplos lo que veo es que la condición de parar es cuando antes del actual
un grupo de elementos que hay que rotar obligatoriamente y después un elemento que no se
pertenece al grupo a rotar en ese momento 


qué cojones pasa cuando encuentra un elemento después del primero?
pues exactamente lo mismo que con los que están antes pero sin contar el primero

1
2
3
aquí se pushean y quedan ordenados

1
3
2
aquí hay que comprobar que no haya nada después del 2


/*
el objetivo de esta función sería hacer lo mismo que la otra función que busca cuantos puede guardar en orden
osea que sería con
*/

/*
resumen:
mientras recorro el stack_b si stk_b >= s_a - i se empuja, rotar en orden, 

cuando ya se ha recorrido el stack empujando todos los número entre s_a - i y s_a
toca rotarlos de vuelta 
*/

/*
mientras condición compleja que busque el siguiente y guarde la posición de cada uno
la primera vez ni comprobamos si está bien el índice porque no puede estar mal
luego miramos que el índice actual no esté después de un salto de más de 1 como en este ejemplo
entre el 2 y 4
4  2
2  9
5  10
3  17
1  20

hay que mirar los saltos de más de uno y que encima de estos saltos no estén los elementos
intermedios

me puedo hacer un array de ints de quinientos y a chuparla
en el primer valor del array pongo el índice donde encuentre al primer elemento buscado y así 
sucesivamente

teniendo esto como puedo comprobar que son válidos los números?

los tres primeros antes de s_a - 1 valen y cada vez que un elemento esté después del primero
se puede ignorar y seguir buscando elementos siguientes a no ser que estén muy lejos

20
9
17(como está después de el segundo no hay problema)
2(este ya si hay que rotarlo por estar antes que el segundo)
10(este no vale por estar después del segundo(17) pero si estuviera antes si)

lo importante a la hora de buscarlos es saber a qué elementos hay que rotar antes de otro
y que el actual no esté después del elemento que hay que empujar después del que hay que rotar antes
así que lo importante es saber los índices de los elementos que antes de pushearlos
haya que rotar el otro stack

entonces solo tengo que guardar el menor de esos índices



la regla SIMPLE es que cuando hayas hecho push a un número y el siguiente a pushear tenga que
rotarse después del ya pusheado ya el siguiente no vale si está después de ese número

para empezar ver si el actual tiene un índice mayor que el primero y que no se pase de un límite
si es mayor y no se pasa buscamos el siguiente
a partir del tercer elemento empezamos a guardar el índice del siguiente cuando haya que rotarlo
eso sería guardar el segundo si el tercero está antes

entonces se empieza guardando el índice del primero que se encuentre antes que s_a - 1
que sería el índice menor, si hay otro menor se guarda el anterior como índice que no se puede
superar y si se supera ya no se actualiza el número a no ser que sea mayor que s_a - 1

LÓGICA FINAL: se guarda el índice más bajo, si un índice es menor que el más bajo
se marca el anterior índice más bajo como el índice que si superas y no superas el de
s_a - 1 ya no vale

la lógica para el proceso de rotar y pushear los elementos es que cada vez que se vaya a 
pushear algo mirar si hay algo ya pusheado y si el ya pusheado es menor se rota todo lo que haya
pusheado y se sigue hasta que en el stackb no haya elementos menores que s_a

*/


ideas principales para bajar el número de movimientos:

1 probar poniendo optimal por sitios random y viendo si bajan los movimientos con el tester
2 haciendo una función que busque cuantos elementos meter al fondo del stack mientras se rota
3 calculando un índice máximo en el que buscar dependiendo de como de grande sea i
4 llevar todos los elementos al stkb y ejecutar sort_b_a y cuando el elemento se pase de n 
ejecutar aux_three_ba hasta que se hayan enviado todos los elementos del grupo mayor y luego ejecutar aux_three_ab
con ese mismo grupo

5 optimizar la función short_ba